import Mathlib.Probability.Independence.Conditional
import Mathlib.Probability.ProbabilityMassFunction.Basic

/-! ## Independent product of probability measures -/

open ProbabilityTheory MeasureTheory

alias MeasureTheory.MeasureSpace.œÉAlg := MeasureSpace.toMeasurableSpace
alias MeasureTheory.MeasureSpace.Œº := MeasureSpace.volume

variable {Œ© : Type*}

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (MeasureSpace Œ©) where
  -- TODO: double-check if we are supposed to use `map` or `comap`
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

/-- The sum of two measurable spaces on the same space `Œ©` is the measurable space generated by the
  union of the two spaces -/
def MeasurableSpace.sum (m‚ÇÅ : MeasurableSpace Œ©) (m‚ÇÇ : MeasurableSpace Œ©) : MeasurableSpace Œ© :=
  MeasurableSpace.generateFrom (MeasurableSet[m‚ÇÅ] ‚à™ MeasurableSet[m‚ÇÇ])

namespace ProbabilityTheory

/-- A probability space is a `MeasureSpace` where the measure is a probability measure (i.e. has
  total measure `1`) -/
class ProbabilitySpace (Œ© : Type*) extends MeasureSpace Œ© where
  [is_prob : IsProbabilityMeasure volume]

def ProbabilitySpace.œÉAlg [P : ProbabilitySpace Œ©] : MeasurableSpace Œ© :=
  ProbabilitySpace.toMeasureSpace.toMeasurableSpace
def ProbabilitySpace.Œº [P : ProbabilitySpace Œ©] : Measure[P.œÉAlg] Œ© :=
  ProbabilitySpace.toMeasureSpace.volume

/-- A probability mass function, under some measurable space, induces a probability space -/
noncomputable def ProbabilitySpace.ofPMF [MeasurableSpace Œ©] (Œº : PMF Œ©) : ProbabilitySpace Œ© :=
  { toMeasurableSpace := inferInstance,
    volume := Œº.toMeasure,
    is_prob := PMF.toMeasure.isProbabilityMeasure Œº }

@[simp]
instance ProbabilitySpace.instProbabilityMeasure [P : ProbabilitySpace Œ©] :
    IsProbabilityMeasure (P.Œº) :=
  ProbabilitySpace.is_prob

@[simp]
lemma ProbabilitySpace.œÉAlg_apply [P : ProbabilitySpace Œ©] :
    P.œÉAlg = P.toMeasureSpace.toMeasurableSpace := rfl
@[simp]
lemma ProbabilitySpace.Œº_apply [P : ProbabilitySpace Œ©] :
    P.Œº = P.toMeasureSpace.volume := rfl

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (ProbabilitySpace Œ©) where
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ, _‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ, _‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ, _‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

end ProbabilityTheory

section IndependentProduct

variable {m‚ÇÅ : MeasurableSpace Œ©} {m‚ÇÇ : MeasurableSpace Œ©}

/-- An independent product of measures `Œº‚ÇÅ` and `Œº‚ÇÇ` (on measurable spaces `m‚ÇÅ` and `m‚ÇÇ`,
    respectively) is a measure `Œº` on the sum of `m‚ÇÅ` and `m‚ÇÇ` that satisfies the product formula -/
@[ext]
class Measure.IndependentProduct (Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©) (Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©) where
  Œº : Measure[MeasurableSpace.sum m‚ÇÅ m‚ÇÇ] Œ©
  inter_eq_prod {X Y} (hX : MeasurableSet[m‚ÇÅ] X) (hY : MeasurableSet[m‚ÇÇ] Y) :
    Œº (X ‚à© Y) = Œº‚ÇÅ X * Œº‚ÇÇ Y

/-- The independent product of two measures is unique, if it exists -/
instance {Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©} {Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©} : Subsingleton (Measure.IndependentProduct Œº‚ÇÅ Œº‚ÇÇ) := by
  constructor
  intro ‚ü®Œº, hŒº‚ü© ‚ü®Œº', hŒº'‚ü©
  ext
  simp
  sorry
  -- To prove this, [Li et al. 2023] requires the Dynkin œÄ-Œª theorem, which is
  -- `MeasurableSpace.induction_on_inter`.

#check IsPiSystem
#check MeasurableSpace.induction_on_inter

noncomputable section

/-- The partial operation of independent product on `MeasureSpace`s, when it exists -/
def MeasureTheory.MeasureSpace.indepProduct (m‚ÇÅ : MeasureSpace Œ©) (m‚ÇÇ : MeasureSpace Œ©) : Option (MeasureSpace Œ©) := by
  classical
  by_cases h : Nonempty (Measure.IndependentProduct m‚ÇÅ.2 m‚ÇÇ.2)
  ¬∑ exact some (@MeasureSpace.mk Œ© (m‚ÇÅ.1.sum m‚ÇÇ.1) (Classical.choice h).Œº)
  ¬∑ exact none

/-- The partial operation of independent product on `ProbabilitySpace`s, when it exists -/
def ProbabilityTheory.ProbabilitySpace.indepProduct (m‚ÇÅ : ProbabilitySpace Œ©) (m‚ÇÇ : ProbabilitySpace Œ©) : Option (ProbabilitySpace Œ©) := by
  classical
  by_cases h : (m‚ÇÅ.toMeasureSpace.indepProduct m‚ÇÇ.toMeasureSpace).isSome
  ¬∑ exact some (@ProbabilitySpace.mk Œ© ((m‚ÇÅ.toMeasureSpace.indepProduct m‚ÇÇ.toMeasureSpace).get h) (by
    sorry))
  ¬∑ exact none

end

end IndependentProduct

#check MeasureSpace

#check MeasureTheory.Measure.IsComplete

/-- A set `s` is almost measurable with respect to a measure space `Œº` if it is sandwiched between
  two measurable sets that have the same measure -/
def almostMeasurableSet [Œº : MeasureSpace Œ©] (s : Set Œ©) :=
  ‚àÉ t‚ÇÅ t‚ÇÇ, MeasurableSet t‚ÇÅ ‚àß MeasurableSet t‚ÇÇ ‚àß t‚ÇÅ ‚äÜ s ‚àß s ‚äÜ t‚ÇÇ ‚àß Œº.volume t‚ÇÅ = Œº.volume t‚ÇÇ

-- I think this is the same as `toMeasurable`, and also `almost measurable` functions in the paper
-- should coincide with the `AEMeasurable` class

#check AEMeasurable
