import Mathlib.Probability.Independence.Conditional
import Mathlib.Probability.ProbabilityMassFunction.Basic

/-! ## Independent product of probability measures -/

open ProbabilityTheory MeasureTheory

alias MeasureTheory.MeasureSpace.œÉAlg := MeasureSpace.toMeasurableSpace
alias MeasureTheory.MeasureSpace.Œº := MeasureSpace.volume

variable {Œ© : Type*}

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (MeasureSpace Œ©) where
  -- TODO: double-check if we are supposed to use `map` or `comap`
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

/-- The sum of two measurable spaces on the same space `Œ©` is the measurable space generated by the
  union of the two spaces -/
def MeasurableSpace.sum (m‚ÇÅ : MeasurableSpace Œ©) (m‚ÇÇ : MeasurableSpace Œ©) : MeasurableSpace Œ© :=
  MeasurableSpace.generateFrom (MeasurableSet[m‚ÇÅ] ‚à™ MeasurableSet[m‚ÇÇ])

namespace MeasurableSpace

/-- Commutativity of measurable-space sum (API). -/
theorem sum_comm (m‚ÇÅ m‚ÇÇ : MeasurableSpace Œ©) :
    MeasurableSpace.sum m‚ÇÅ m‚ÇÇ = MeasurableSpace.sum m‚ÇÇ m‚ÇÅ := by
  -- Follows from commutativity of union and `generateFrom` monotonicity.
  rw [MeasurableSpace.sum, MeasurableSpace.sum, Set.union_comm]

/-- Characterization of measurability at the bottom measurable space (stated API). -/
theorem measurableSet_bot_iff_empty_or_univ {s : Set Œ©} :
    MeasurableSet[‚ä•] s ‚Üî s = ‚àÖ ‚à® s = Set.univ := by
  -- In the bottom œÉ-algebra, only `‚àÖ` and `univ` are measurable.
  sorry

/-- Left unit: bottom sums to the other measurable space (API). -/
theorem bot_sum (m : MeasurableSpace Œ©) :
    MeasurableSpace.sum (‚ä• : MeasurableSpace Œ©) m = m := by
  -- Follows since `MeasurableSet[‚ä•] = ‚àÖ`.
  simp [MeasurableSpace.sum]
  sorry

/-- Right unit: summing with bottom yields the same space (API). -/
theorem sum_bot (m : MeasurableSpace Œ©) :
    MeasurableSpace.sum m (‚ä• : MeasurableSpace Œ©) = m := by
  -- Follows since `MeasurableSet[‚ä•] = ‚àÖ`.
  simp [MeasurableSpace.sum, Set.union_comm]
  sorry

end MeasurableSpace

namespace ProbabilityTheory

/-- A probability space is a `MeasureSpace` where the measure is a probability measure (i.e. has
  total measure `1`) -/
class ProbabilitySpace (Œ© : Type*) extends MeasureSpace Œ© where
  [is_prob : IsProbabilityMeasure volume]

def ProbabilitySpace.œÉAlg [P : ProbabilitySpace Œ©] : MeasurableSpace Œ© :=
  ProbabilitySpace.toMeasureSpace.toMeasurableSpace
def ProbabilitySpace.Œº [P : ProbabilitySpace Œ©] : Measure[P.œÉAlg] Œ© :=
  ProbabilitySpace.toMeasureSpace.volume

/-- A probability mass function, under some measurable space, induces a probability space -/
noncomputable def ProbabilitySpace.ofPMF [MeasurableSpace Œ©] (Œº : PMF Œ©) : ProbabilitySpace Œ© :=
  { toMeasurableSpace := inferInstance,
    volume := Œº.toMeasure,
    is_prob := PMF.toMeasure.isProbabilityMeasure Œº }

@[simp]
instance ProbabilitySpace.instProbabilityMeasure [P : ProbabilitySpace Œ©] :
    IsProbabilityMeasure (P.Œº) :=
  ProbabilitySpace.is_prob

@[simp]
lemma ProbabilitySpace.œÉAlg_apply [P : ProbabilitySpace Œ©] :
    P.œÉAlg = P.toMeasureSpace.toMeasurableSpace := rfl
@[simp]
lemma ProbabilitySpace.Œº_apply [P : ProbabilitySpace Œ©] :
    P.Œº = P.toMeasureSpace.volume := rfl

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (ProbabilitySpace Œ©) where
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ, _‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ, _‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ, _‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

end ProbabilityTheory

/-! ### Canonical unit probability space

We provide `One (ProbabilitySpace Œ©)` as the Dirac measure at a chosen point,
requiring `[Nonempty Œ©]`. -/

noncomputable section

variable {Œ© : Type*}

instance [inst : Nonempty Œ©] : One (ProbabilityTheory.ProbabilitySpace Œ©) where
  one := @ProbabilityTheory.ProbabilitySpace.mk Œ©
    (@MeasureTheory.MeasureSpace.mk Œ© ‚ä•
      (@MeasureTheory.Measure.dirac _ ‚ä• (Classical.choice inst)))
    (by constructor; simp [MeasureTheory.Measure.dirac])

end

section IndependentProduct

variable {m‚ÇÅ : MeasurableSpace Œ©} {m‚ÇÇ : MeasurableSpace Œ©}

/-- An independent product of measures `Œº‚ÇÅ` and `Œº‚ÇÇ` (on measurable spaces `m‚ÇÅ` and `m‚ÇÇ`,
    respectively) is a measure `Œº` on the sum of `m‚ÇÅ` and `m‚ÇÇ` that satisfies the product formula -/
@[ext]
class Measure.IndependentProduct (Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©) (Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©) where
  Œº : Measure[MeasurableSpace.sum m‚ÇÅ m‚ÇÇ] Œ©
  inter_eq_prod {X Y} (hX : MeasurableSet[m‚ÇÅ] X) (hY : MeasurableSet[m‚ÇÇ] Y) :
    Œº (X ‚à© Y) = Œº‚ÇÅ X * Œº‚ÇÇ Y

variable {m‚ÇÅ m‚ÇÇ : MeasurableSpace Œ©} {Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©} {Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©}

/-- Symmetry: swap factors of an independent product (API). -/
def Measure.IndependentProduct.symm
    (w : Measure.IndependentProduct Œº‚ÇÅ Œº‚ÇÇ) :
    Measure.IndependentProduct Œº‚ÇÇ Œº‚ÇÅ := by
  -- Build the symmetric witness using `MeasurableSpace.sum_comm` and `mul_comm`.
  sorry

/-- The independent product of two measures is unique, if it exists -/
instance {Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©} {Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©} : Subsingleton (Measure.IndependentProduct Œº‚ÇÅ Œº‚ÇÇ) := by
  constructor
  intro ‚ü®Œº, hŒº‚ü© ‚ü®Œº', hŒº'‚ü©
  ext
  simp
  sorry
  -- To prove this, [Li et al. 2023] requires the Dynkin œÄ-Œª theorem, which is
  -- `MeasurableSpace.induction_on_inter`.

#check IsPiSystem
#check MeasurableSpace.induction_on_inter

noncomputable section

/-- The partial operation of independent product on `MeasureSpace`s, when it exists -/
def MeasureTheory.MeasureSpace.indepProduct (m‚ÇÅ : MeasureSpace Œ©) (m‚ÇÇ : MeasureSpace Œ©) : Option (MeasureSpace Œ©) := by
  classical
  by_cases h : Nonempty (Measure.IndependentProduct m‚ÇÅ.2 m‚ÇÇ.2)
  ¬∑ exact some (@MeasureSpace.mk Œ© (m‚ÇÅ.1.sum m‚ÇÇ.1) (Classical.choice h).Œº)
  ¬∑ exact none

namespace MeasureTheory
namespace MeasureSpace

variable {Œ© : Type*}

/-- Commutativity (API): independent product at the `MeasureSpace` level is commutative. -/
theorem indepProduct_comm (m‚ÇÅ m‚ÇÇ : MeasureSpace Œ©) :
    indepProduct (Œ© := Œ©) m‚ÇÅ m‚ÇÇ = indepProduct (Œ© := Œ©) m‚ÇÇ m‚ÇÅ := by
  -- Build the symmetric witness and use `MeasurableSpace.sum_comm`.
  sorry

/-- Associativity (API): reassociating the triple independent product yields the same result. -/
theorem indepProduct_assoc (m‚ÇÅ m‚ÇÇ m‚ÇÉ : MeasureSpace Œ©) :
    (do let ab ‚Üê indepProduct (Œ© := Œ©) m‚ÇÅ m‚ÇÇ; indepProduct (Œ© := Œ©) ab m‚ÇÉ) =
    (do let bc ‚Üê indepProduct (Œ© := Œ©) m‚ÇÇ m‚ÇÉ; indepProduct (Œ© := Œ©) m‚ÇÅ bc) := by
  -- Proof via measurable-space isomorphism between sums; deferred.
  sorry

/-- Corollary: existence of the independent product is symmetric. -/
theorem indepProduct_isSome_comm (m‚ÇÅ m‚ÇÇ : MeasureSpace Œ©) :
    (indepProduct (Œ© := Œ©) m‚ÇÅ m‚ÇÇ).isSome = (indepProduct (Œ© := Œ©) m‚ÇÇ m‚ÇÅ).isSome := by
  -- Immediate from commutativity.
  sorry

end MeasureSpace
end MeasureTheory

/-- The partial operation of independent product on `ProbabilitySpace`s, when it exists -/
def ProbabilityTheory.ProbabilitySpace.indepProduct (m‚ÇÅ : ProbabilitySpace Œ©) (m‚ÇÇ : ProbabilitySpace Œ©) : Option (ProbabilitySpace Œ©) := by
  classical
  -- Re-express in terms of existence of an independent product witness to build the space and certify probability.
  by_cases h : Nonempty (Measure.IndependentProduct m‚ÇÅ.Œº m‚ÇÇ.Œº)
  ¬∑ -- Build the combined `MeasureSpace` from the witness and prove it's a `ProbabilitySpace` by Œº(univ)=1.
    refine some
      { toMeasureSpace := @MeasureSpace.mk Œ© (m‚ÇÅ.œÉAlg.sum m‚ÇÇ.œÉAlg) (Classical.choice h).Œº
        is_prob := by
          -- `Œº(univ) = 1` follows from the rectangle formula with X=univ, Y=univ.
          have hX : MeasurableSet[m‚ÇÅ.œÉAlg] (Set.univ) := by simp
          have hY : MeasurableSet[m‚ÇÇ.œÉAlg] (Set.univ) := by simp
          have hŒº : (Classical.choice h).Œº (Set.univ) = m‚ÇÅ.Œº Set.univ * m‚ÇÇ.Œº Set.univ := by
            simpa [Set.univ_inter] using (Classical.choice h).inter_eq_prod (X := Set.univ) (Y := Set.univ) hX hY
          have hŒº1 : m‚ÇÅ.Œº Set.univ = 1 := by simpa using (inferInstance : IsProbabilityMeasure m‚ÇÅ.Œº).measure_univ
          have hŒº2 : m‚ÇÇ.Œº Set.univ = 1 := by simpa using (inferInstance : IsProbabilityMeasure m‚ÇÇ.Œº).measure_univ
          constructor
          rw [hŒº1, hŒº2] at hŒº
          simp at hŒº
          simpa only [œÉAlg_apply, Œº_apply] using hŒº }
  ¬∑ -- No independent product witness exists at the measure level.
    exact none

end

end IndependentProduct

namespace ProbabilityTheory

namespace ProbabilitySpace

variable {Œ© : Type*}

/-- Symmetry: independent product is commutative (API statement). -/
theorem indepProduct_comm (m‚ÇÅ m‚ÇÇ : ProbabilitySpace Œ©) :
    indepProduct m‚ÇÅ m‚ÇÇ = indepProduct m‚ÇÇ m‚ÇÅ := by
  -- Proof via swapping factors and uniqueness of independent product.
  sorry

/-- Left unit: the unit probability space acts as a left identity for `indepProduct` (API).
Requires `[Nonempty Œ©]` to use the canonical Dirac-on-a-point unit. -/
@[simp]
theorem indepProduct_one_left [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    indepProduct (1 : ProbabilitySpace Œ©) m = some m := by
  -- Proof via rectangle formula on univ and uniqueness.
  sorry

/-- Right unit: the unit probability space acts as a right identity for `indepProduct` (API).
Requires `[Nonempty Œ©]` to use the canonical Dirac-on-a-point unit. -/
@[simp]
theorem indepProduct_one_right [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    indepProduct m (1 : ProbabilitySpace Œ©) = some m := by
  -- Proof via rectangle formula on univ and uniqueness.
  sorry

/-- Associativity: reassociating a triple independent product yields the same result (API). -/
theorem indepProduct_assoc (m‚ÇÅ m‚ÇÇ m‚ÇÉ : ProbabilitySpace Œ©) :
    (do let ab ‚Üê indepProduct m‚ÇÅ m‚ÇÇ; indepProduct ab m‚ÇÉ) =
    (do let bc ‚Üê indepProduct m‚ÇÇ m‚ÇÉ; indepProduct m‚ÇÅ bc) := by
  -- Proof via measurable space isomorphism between (m‚ÇÅ ‚äï m‚ÇÇ) ‚äï m‚ÇÉ and m‚ÇÅ ‚äï (m‚ÇÇ ‚äï m‚ÇÉ)
  -- and uniqueness of independent products.
  sorry

/-- Bridge: mapping `ProbabilitySpace.indepProduct` down to `MeasureSpace` agrees with
`MeasureSpace.indepProduct` (API). -/
theorem indepProduct_toMeasureSpace_map (m‚ÇÅ m‚ÇÇ : ProbabilitySpace Œ©) :
    Option.map (fun P => P.toMeasureSpace) (indepProduct m‚ÇÅ m‚ÇÇ) =
      MeasureTheory.MeasureSpace.indepProduct (Œ© := Œ©)
        (m‚ÇÅ.toMeasureSpace) (m‚ÇÇ.toMeasureSpace) := by
  -- Follows by unfolding both definitions and comparing witnesses
  simp [ProbabilitySpace.toMeasureSpace, ProbabilitySpace.indepProduct, MeasureSpace.indepProduct]

/-- Mapped commutativity: after mapping to `MeasureSpace`, `indepProduct` is commutative. -/
theorem indepProduct_comm_toMeasureSpace (m‚ÇÅ m‚ÇÇ : ProbabilitySpace Œ©) :
    Option.map (fun P => P.toMeasureSpace) (indepProduct m‚ÇÅ m‚ÇÇ) =
    Option.map (fun P => P.toMeasureSpace) (indepProduct m‚ÇÇ m‚ÇÅ) := by
  -- Rewrite both sides to `MeasureSpace.indepProduct` and use its commutativity.
  calc
    Option.map (fun P => P.toMeasureSpace) (indepProduct m‚ÇÅ m‚ÇÇ)
        = MeasureTheory.MeasureSpace.indepProduct (Œ© := Œ©) (m‚ÇÅ.toMeasureSpace) (m‚ÇÇ.toMeasureSpace) := by
          simp [indepProduct_toMeasureSpace_map]
    _ = MeasureTheory.MeasureSpace.indepProduct (Œ© := Œ©) (m‚ÇÇ.toMeasureSpace) (m‚ÇÅ.toMeasureSpace) := by
          simpa using MeasureTheory.MeasureSpace.indepProduct_comm (Œ© := Œ©) (m‚ÇÅ.toMeasureSpace) (m‚ÇÇ.toMeasureSpace)
    _ = Option.map (fun P => P.toMeasureSpace) (indepProduct m‚ÇÇ m‚ÇÅ) := by
          simp [indepProduct_toMeasureSpace_map]

/-- Mapped associativity (API): after mapping to `MeasureSpace`, the triple product reassociates. -/
theorem indepProduct_assoc_toMeasureSpace (m‚ÇÅ m‚ÇÇ m‚ÇÉ : ProbabilitySpace Œ©) :
    Option.map (fun P => P.toMeasureSpace)
      (do let ab ‚Üê indepProduct m‚ÇÅ m‚ÇÇ; indepProduct ab m‚ÇÉ) =
    Option.map (fun P => P.toMeasureSpace)
      (do let bc ‚Üê indepProduct m‚ÇÇ m‚ÇÉ; indepProduct m‚ÇÅ bc) := by
  -- Delegate to `MeasureSpace.indepProduct_assoc` via the bridge; details deferred.
  sorry

/-- Mapped left unit (API). -/
@[simp] theorem indepProduct_one_left_toMeasureSpace [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    Option.map (fun P => P.toMeasureSpace) (indepProduct (1 : ProbabilitySpace Œ©) m)
      = some m.toMeasureSpace := by
  -- Proof via bridge to `MeasureSpace` and unit at that level; deferred.
  sorry

/-- Mapped right unit (API). -/
@[simp] theorem indepProduct_one_right_toMeasureSpace [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    Option.map (fun P => P.toMeasureSpace) (indepProduct m (1 : ProbabilitySpace Œ©))
      = some m.toMeasureSpace := by
  -- Proof via bridge to `MeasureSpace` and unit at that level; deferred.
  sorry

end ProbabilitySpace

end ProbabilityTheory

#check MeasureSpace

#check MeasureTheory.Measure.IsComplete

/-- A set `s` is almost measurable with respect to a measure space `Œº` if it is sandwiched between
  two measurable sets that have the same measure -/
def almostMeasurableSet [Œº : MeasureSpace Œ©] (s : Set Œ©) :=
  ‚àÉ t‚ÇÅ t‚ÇÇ, MeasurableSet t‚ÇÅ ‚àß MeasurableSet t‚ÇÇ ‚àß t‚ÇÅ ‚äÜ s ‚àß s ‚äÜ t‚ÇÇ ‚àß Œº.volume t‚ÇÅ = Œº.volume t‚ÇÇ

-- I think this is the same as `toMeasurable`, and also `almost measurable` functions in the paper
-- should coincide with the `AEMeasurable` class

#check AEMeasurable
