import Mathlib.Probability.Independence.Conditional
import Mathlib.Probability.ProbabilityMassFunction.Basic

/-! ## Independent product of probability measures -/

open ProbabilityTheory MeasureTheory

alias MeasureTheory.MeasureSpace.œÉAlg := MeasureSpace.toMeasurableSpace
alias MeasureTheory.MeasureSpace.Œº := MeasureSpace.volume

variable {Œ© : Type*}

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (MeasureSpace Œ©) where
  -- TODO: double-check if we are supposed to use `map` or `comap`
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

/-- The sum of two measurable spaces on the same space `Œ©` is the measurable space generated by the
  union of the two spaces -/
def MeasurableSpace.sum (m‚ÇÅ : MeasurableSpace Œ©) (m‚ÇÇ : MeasurableSpace Œ©) : MeasurableSpace Œ© :=
  MeasurableSpace.generateFrom (MeasurableSet[m‚ÇÅ] ‚à™ MeasurableSet[m‚ÇÇ])

namespace ProbabilityTheory

/-- A probability space is a `MeasureSpace` where the measure is a probability measure (i.e. has
  total measure `1`) -/
class ProbabilitySpace (Œ© : Type*) extends MeasureSpace Œ© where
  [is_prob : IsProbabilityMeasure volume]

def ProbabilitySpace.œÉAlg [P : ProbabilitySpace Œ©] : MeasurableSpace Œ© :=
  ProbabilitySpace.toMeasureSpace.toMeasurableSpace
def ProbabilitySpace.Œº [P : ProbabilitySpace Œ©] : Measure[P.œÉAlg] Œ© :=
  ProbabilitySpace.toMeasureSpace.volume

/-- A probability mass function, under some measurable space, induces a probability space -/
noncomputable def ProbabilitySpace.ofPMF [MeasurableSpace Œ©] (Œº : PMF Œ©) : ProbabilitySpace Œ© :=
  { toMeasurableSpace := inferInstance,
    volume := Œº.toMeasure,
    is_prob := PMF.toMeasure.isProbabilityMeasure Œº }

@[simp]
instance ProbabilitySpace.instProbabilityMeasure [P : ProbabilitySpace Œ©] :
    IsProbabilityMeasure (P.Œº) :=
  ProbabilitySpace.is_prob

@[simp]
lemma ProbabilitySpace.œÉAlg_apply [P : ProbabilitySpace Œ©] :
    P.œÉAlg = P.toMeasureSpace.toMeasurableSpace := rfl
@[simp]
lemma ProbabilitySpace.Œº_apply [P : ProbabilitySpace Œ©] :
    P.Œº = P.toMeasureSpace.volume := rfl

/-- We define `(‚Ñ±, Œº) ‚â§ (ùí¢, ŒΩ)` if `‚Ñ± ‚â§ ùí¢` and `Œº` is the restriction of `ŒΩ` to `‚Ñ±` -/
instance : Preorder (ProbabilitySpace Œ©) where
  le m‚ÇÅ m‚ÇÇ := (m‚ÇÅ.œÉAlg ‚â§ m‚ÇÇ.œÉAlg) ‚àß m‚ÇÅ.Œº = (@Measure.map _ _ m‚ÇÇ.œÉAlg m‚ÇÅ.œÉAlg id m‚ÇÇ.Œº)
  le_refl m := by simp only [LE.le, imp_self, implies_true, Measure.map_id, and_self]
  le_trans := by
    rintro ‚ü®‚Ñ±‚ÇÅ, Œº‚ÇÅ, _‚ü© ‚ü®‚Ñ±‚ÇÇ, Œº‚ÇÇ, _‚ü© ‚ü®‚Ñ±‚ÇÉ, Œº‚ÇÉ, _‚ü© ‚ü®h‚Ñ±‚ÇÅ‚ÇÇ, hŒº‚ÇÅ‚ÇÇ‚ü© ‚ü®h‚Ñ±‚ÇÇ‚ÇÉ, hŒº‚ÇÇ‚ÇÉ‚ü©
    simp_all
    refine ‚ü®le_trans h‚Ñ±‚ÇÅ‚ÇÇ h‚Ñ±‚ÇÇ‚ÇÉ, ?_‚ü©
    ¬∑ rw [Measure.map_map] <;> aesop

end ProbabilityTheory

/-! ### Canonical unit probability space

We provide `One (ProbabilitySpace Œ©)` as the Dirac measure at a chosen point,
requiring `[Nonempty Œ©]`. -/

noncomputable section

variable {Œ© : Type*}

instance [inst : Nonempty Œ©] : One (ProbabilityTheory.ProbabilitySpace Œ©) where
  one := @ProbabilityTheory.ProbabilitySpace.mk Œ©
    (@MeasureTheory.MeasureSpace.mk Œ© ‚ä•
      (@MeasureTheory.Measure.dirac _ ‚ä• (Classical.choice inst)))
    (by constructor; simp [MeasureTheory.Measure.dirac])

end

section IndependentProduct

variable {m‚ÇÅ : MeasurableSpace Œ©} {m‚ÇÇ : MeasurableSpace Œ©}

/-- An independent product of measures `Œº‚ÇÅ` and `Œº‚ÇÇ` (on measurable spaces `m‚ÇÅ` and `m‚ÇÇ`,
    respectively) is a measure `Œº` on the sum of `m‚ÇÅ` and `m‚ÇÇ` that satisfies the product formula -/
@[ext]
class Measure.IndependentProduct (Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©) (Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©) where
  Œº : Measure[MeasurableSpace.sum m‚ÇÅ m‚ÇÇ] Œ©
  inter_eq_prod {X Y} (hX : MeasurableSet[m‚ÇÅ] X) (hY : MeasurableSet[m‚ÇÇ] Y) :
    Œº (X ‚à© Y) = Œº‚ÇÅ X * Œº‚ÇÇ Y

/-- The independent product of two measures is unique, if it exists -/
instance {Œº‚ÇÅ : Measure[m‚ÇÅ] Œ©} {Œº‚ÇÇ : Measure[m‚ÇÇ] Œ©} : Subsingleton (Measure.IndependentProduct Œº‚ÇÅ Œº‚ÇÇ) := by
  constructor
  intro ‚ü®Œº, hŒº‚ü© ‚ü®Œº', hŒº'‚ü©
  ext
  simp
  sorry
  -- To prove this, [Li et al. 2023] requires the Dynkin œÄ-Œª theorem, which is
  -- `MeasurableSpace.induction_on_inter`.

#check IsPiSystem
#check MeasurableSpace.induction_on_inter

noncomputable section

/-- The partial operation of independent product on `MeasureSpace`s, when it exists -/
def MeasureTheory.MeasureSpace.indepProduct (m‚ÇÅ : MeasureSpace Œ©) (m‚ÇÇ : MeasureSpace Œ©) : Option (MeasureSpace Œ©) := by
  classical
  by_cases h : Nonempty (Measure.IndependentProduct m‚ÇÅ.2 m‚ÇÇ.2)
  ¬∑ exact some (@MeasureSpace.mk Œ© (m‚ÇÅ.1.sum m‚ÇÇ.1) (Classical.choice h).Œº)
  ¬∑ exact none

/-- The partial operation of independent product on `ProbabilitySpace`s, when it exists -/
def ProbabilityTheory.ProbabilitySpace.indepProduct (m‚ÇÅ : ProbabilitySpace Œ©) (m‚ÇÇ : ProbabilitySpace Œ©) : Option (ProbabilitySpace Œ©) := by
  classical
  -- Re-express in terms of existence of an independent product witness to build the space and certify probability.
  by_cases h : Nonempty (Measure.IndependentProduct m‚ÇÅ.Œº m‚ÇÇ.Œº)
  ¬∑ -- Build the combined `MeasureSpace` from the witness and prove it's a `ProbabilitySpace` by Œº(univ)=1.
    refine some
      { toMeasureSpace := @MeasureSpace.mk Œ© (m‚ÇÅ.œÉAlg.sum m‚ÇÇ.œÉAlg) (Classical.choice h).Œº
        is_prob := by
          -- `Œº(univ) = 1` follows from the rectangle formula with X=univ, Y=univ.
          have hX : MeasurableSet[m‚ÇÅ.œÉAlg] (Set.univ) := by simp
          have hY : MeasurableSet[m‚ÇÇ.œÉAlg] (Set.univ) := by simp
          have hŒº : (Classical.choice h).Œº (Set.univ) = m‚ÇÅ.Œº Set.univ * m‚ÇÇ.Œº Set.univ := by
            simpa [Set.univ_inter] using (Classical.choice h).inter_eq_prod (X := Set.univ) (Y := Set.univ) hX hY
          have hŒº1 : m‚ÇÅ.Œº Set.univ = 1 := by simpa using (inferInstance : IsProbabilityMeasure m‚ÇÅ.Œº).measure_univ
          have hŒº2 : m‚ÇÇ.Œº Set.univ = 1 := by simpa using (inferInstance : IsProbabilityMeasure m‚ÇÇ.Œº).measure_univ
          constructor
          rw [hŒº1, hŒº2] at hŒº
          simp at hŒº
          simpa only [œÉAlg_apply, Œº_apply] using hŒº }
  ¬∑ -- No independent product witness exists at the measure level.
    exact none

end

end IndependentProduct

namespace ProbabilityTheory

namespace ProbabilitySpace

variable {Œ© : Type*}

/-- Symmetry: independent product is commutative (API statement). -/
theorem indepProduct_comm (m‚ÇÅ m‚ÇÇ : ProbabilitySpace Œ©) :
    indepProduct m‚ÇÅ m‚ÇÇ = indepProduct m‚ÇÇ m‚ÇÅ := by
  -- Proof via swapping factors and uniqueness of independent product.
  sorry

/-- Left unit: the unit probability space acts as a left identity for `indepProduct` (API).
Requires `[Nonempty Œ©]` to use the canonical Dirac-on-a-point unit. -/
theorem indepProduct_one_left [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    indepProduct (1 : ProbabilitySpace Œ©) m = some m := by
  -- Proof via rectangle formula on univ and uniqueness.
  sorry

/-- Right unit: the unit probability space acts as a right identity for `indepProduct` (API).
Requires `[Nonempty Œ©]` to use the canonical Dirac-on-a-point unit. -/
theorem indepProduct_one_right [Nonempty Œ©] (m : ProbabilitySpace Œ©) :
    indepProduct m (1 : ProbabilitySpace Œ©) = some m := by
  -- Proof via rectangle formula on univ and uniqueness.
  sorry

/-- Associativity: reassociating a triple independent product yields the same result (API). -/
theorem indepProduct_assoc (m‚ÇÅ m‚ÇÇ m‚ÇÉ : ProbabilitySpace Œ©) :
    (do let ab ‚Üê indepProduct m‚ÇÅ m‚ÇÇ; indepProduct ab m‚ÇÉ) =
    (do let bc ‚Üê indepProduct m‚ÇÇ m‚ÇÉ; indepProduct m‚ÇÅ bc) := by
  -- Proof via measurable space isomorphism between (m‚ÇÅ ‚äï m‚ÇÇ) ‚äï m‚ÇÉ and m‚ÇÅ ‚äï (m‚ÇÇ ‚äï m‚ÇÉ)
  -- and uniqueness of independent products.
  sorry

end ProbabilitySpace

end ProbabilityTheory

#check MeasureSpace

#check MeasureTheory.Measure.IsComplete

/-- A set `s` is almost measurable with respect to a measure space `Œº` if it is sandwiched between
  two measurable sets that have the same measure -/
def almostMeasurableSet [Œº : MeasureSpace Œ©] (s : Set Œ©) :=
  ‚àÉ t‚ÇÅ t‚ÇÇ, MeasurableSet t‚ÇÅ ‚àß MeasurableSet t‚ÇÇ ‚àß t‚ÇÅ ‚äÜ s ‚àß s ‚äÜ t‚ÇÇ ‚àß Œº.volume t‚ÇÅ = Œº.volume t‚ÇÇ

-- I think this is the same as `toMeasurable`, and also `almost measurable` functions in the paper
-- should coincide with the `AEMeasurable` class

#check AEMeasurable
