import Mathlib
import Iris
import Bluebell.Algebra.Probability
import Bluebell.Algebra.Permission
import Bluebell.Algebra.PSpPm
import Bluebell.Algebra.HyperAssertion

namespace Bluebell

open Iris ProbabilityTheory MeasureTheory HyperAssertion

variable {I Œ± V F : Type*} [Nonempty V] [UFraction F]

-- /-- Order on the IndexedPSpPm is CMRA inclusion. -/
-- noncomputable instance : LE (IndexedPSpPm I Œ± V F) := instLE_bluebell

noncomputable section

/-- Ownership of an indexed tuple of probability spaces `P : I ‚Üí ProbabilitySpace (Œ± ‚Üí V)`
and permissions `p : I ‚Üí Permission Œ± F`, given compatibility witnesses. -/
def ownIndexedTuple (P : I ‚Üí ProbabilityTheory.ProbabilitySpace (Œ± ‚Üí V)) (p : I ‚Üí Permission Œ± F) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun h : ‚àÄ i, ProbabilityTheory.ProbabilitySpace.compatiblePerm (P i) (p i) =>
    own (M := IndexedPSpPm I Œ± V F) (fun i => ‚ü®‚ü®WithTop.some (P i), p i‚ü©, h i‚ü©))

/-- Ownership of an indexed probability spaces `P : I ‚Üí ProbabilitySpace (Œ± ‚Üí V)`,
defined as the existence of a compatible indexed permission. -/
def ownIndexedProb (P : I ‚Üí ProbabilityTheory.ProbabilitySpace (Œ± ‚Üí V)) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun p : I ‚Üí Permission Œ± F => ownIndexedTuple (I := I) (Œ± := Œ±) (V := V) (F := F) P p)

variable [DecidableEq I] [Nonempty V]

/-- The hyper-assertion `E‚ü®i‚ü© ‚àº Œº`. -/
def assertSampledFrom {Œ≤ : Type*} [MeasurableSpace Œ≤] (i : I) (E : (Œ± ‚Üí V) ‚Üí Œ≤) (Œº : PMF Œ≤) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun P : I ‚Üí ProbabilityTheory.ProbabilitySpace (Œ± ‚Üí V) =>
    sep (ownIndexedProb (I := I) (Œ± := Œ±) (V := V) (F := F) P)
      (pure (@AEMeasurable _ _ _ (P i).œÉAlg E (P i).Œº ‚àß
        Œº.toMeasure = @Measure.map _ _ (P i).œÉAlg _ E (P i).Œº)))

/-- Assertion that the expected value of `E` at index `i` is `ev`. -/
def assertExpectation {Œ≤ : Type*} [MeasurableSpace Œ≤] [TopologicalSpace Œ≤]
    [AddCommMonoid Œ≤] [SMul ENNReal Œ≤]
    (i : I) (E : (Œ± ‚Üí V) ‚Üí Œ≤) (ev : Œ≤) : HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun Œº => sep (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E Œº)
    (pure (ev = ‚àë' b, (Œº b) ‚Ä¢ b)))

/-- Assertion that the probability of a Boolean-valued expression `E` at index `i` is `prob`. -/
def assertProbability (i : I) (E : (Œ± ‚Üí V) ‚Üí Bool) (prob : ENNReal) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun Œº => sep (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E Œº)
    (pure (prob = Œº true)))

/-- Assertion that `E` is true almost surely. -/
noncomputable def assertTrue (i : I) (E : (Œ± ‚Üí V) ‚Üí Bool) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E (PMF.pure true)

/-- Assertion that we own `E` (but its distribution is not known). -/
def assertOwn {Œ≤ : Type*} [MeasurableSpace Œ≤] (i : I) (E : (Œ± ‚Üí V) ‚Üí Œ≤) :
    HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun Œº => assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E Œº)

/-- Assertion that the variable `x : Œ±` at index `i` has permission `q : Frac F`. -/
def assertPermissionVar (i : I) (x : Œ±) (q : Frac F) : HyperAssertion (IndexedPSpPm I Œ± V F) :=
  ¬´exists¬ª (fun Pp : IndexedPSpPm I Œ± V F =>
    sep (own (M := IndexedPSpPm I Œ± V F) Pp)
        (pure ((Pp i).1.2 x = DFrac.own (q : F))))

/-- Conjoin a `P` with ownership derived from a compatible `p`. -/
def assertPermission (P : HyperAssertion (IndexedPSpPm I Œ± V F)) (p : I ‚Üí Permission Œ± F) : HyperAssertion (IndexedPSpPm I Œ± V F) :=
  and P <|
    ¬´exists¬ª
      (fun compatP :
        {P : I ‚Üí ProbabilityTheory.ProbabilitySpace (Œ± ‚Üí V) //
          ‚àÄ i, ProbabilityTheory.ProbabilitySpace.compatiblePerm (P i) (p i)} =>
      own (M := IndexedPSpPm I Œ± V F) (fun i => ‚ü®‚ü®WithTop.some (compatP.1 i), p i‚ü©, compatP.2 i‚ü©))

end

open HyperAssertion

variable {I Œ± V F : Type*} [Nonempty V] [UFraction F]

/-! ### Ownership rules (moved from Basic) -/

section Rules

variable [DecidableEq I]

/-- If `P` and `Q` affect disjoint sets of indices, then `P ‚àß Q` entails `P ‚àó Q`. -/
theorem sep_of_and [Fintype I]
    {P Q : HyperAssertion (IndexedPSpPm I Œ± V F)}
    (h : HyperAssertion.relevantIndices (I := I) P ‚à©
         HyperAssertion.relevantIndices (M := PSpPm Œ± V F) (I := I) Q = ‚àÖ) :
    HyperAssertion.entails (HyperAssertion.and P Q) (HyperAssertion.sep P Q) := by
  sorry

/-- If `E‚ü®i‚ü©` is sampled from both `Œº` and `Œº'`, then `‚åú Œº = Œº' ‚åù` holds as a proposition. -/
theorem sampledFrom_inj {Œ≤ : Type*} [MeasurableSpace Œ≤]
    {i : I} {E : (Œ± ‚Üí V) ‚Üí Œ≤} {Œº Œº' : PMF Œ≤} :
    HyperAssertion.entails
      (HyperAssertion.and
        (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E Œº)
        (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E Œº'))
      (HyperAssertion.pure (Œº = Œº')) := by
  sorry

/-- `E‚ÇÅ‚ü®i‚ü©` and `E‚ÇÇ‚ü®i‚ü©` are both true iff `E‚ÇÅ‚ü®i‚ü© ‚àß E‚ÇÇ‚ü®i‚ü©` is true. -/
theorem sep_assertTrue_iff {i : I} {E‚ÇÅ E‚ÇÇ : (Œ± ‚Üí V) ‚Üí Bool} :
    HyperAssertion.equiv
      (HyperAssertion.sep
        (assertTrue (I := I) (Œ± := Œ±) (V := V) (F := F) i E‚ÇÅ)
        (assertTrue (I := I) (Œ± := Œ±) (V := V) (F := F) i E‚ÇÇ))
      (assertTrue (I := I) (Œ± := Œ±) (V := V) (F := F) i (fun x => E‚ÇÅ x ‚àß E‚ÇÇ x)) := by
  sorry

/-- If `pabs(ùëÉ, pvar(ùê∏‚ü®ùëñ‚ü©))` (to be defined), then `assertTrue i E ‚àß P` entails `assertTrue i E ‚àó P`. -/
theorem sep_of_and_assertTrue {i : I} {E : (Œ± ‚Üí V) ‚Üí Bool}
    {P : HyperAssertion (IndexedPSpPm I Œ± V F)} (h : True) :
    HyperAssertion.entails
      (HyperAssertion.sep
        (assertTrue (I := I) (Œ± := Œ±) (V := V) (F := F) i E)
        P)
      (HyperAssertion.and
        (assertTrue (I := I) (Œ± := Œ±) (V := V) (F := F) i E)
        P) := by
  sorry

/-- Sampling on a product splits into sampling each component. -/
theorem sampledFrom_prod {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _}
    [MeasurableSpace Œ≤‚ÇÅ] [MeasurableSpace Œ≤‚ÇÇ] {i : I}
    (E‚ÇÅ : (Œ± ‚Üí V) ‚Üí Œ≤‚ÇÅ) (E‚ÇÇ : (Œ± ‚Üí V) ‚Üí Œ≤‚ÇÇ)
    (Œº‚ÇÅ : PMF Œ≤‚ÇÅ) (Œº‚ÇÇ : PMF Œ≤‚ÇÇ) :
    HyperAssertion.entails
      (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i (fun x => (E‚ÇÅ x, E‚ÇÇ x))
        (Prod.mk <$> Œº‚ÇÅ <*> Œº‚ÇÇ))
      (HyperAssertion.sep
        (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E‚ÇÅ Œº‚ÇÅ)
        (assertSampledFrom (I := I) (Œ± := Œ±) (V := V) (F := F) i E‚ÇÇ Œº‚ÇÇ)) := by
  sorry

end Rules

end Bluebell

#min_imports
